# -*- coding: utf-8 -*-
"""Genetic Algorithm codes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XeRN8HPFBSbP-l69VWBq1GG8cQsbOv6j
"""

#task1


import random as rdm


def inputfile():
    cap = float(input("Enter Initial Capital : "))
    print(cap)
    gen = int(input("Enter Generations: "))
    print(gen)
    h_prices = list(map(float, input("Enter Historical Prices: ").split(',')))
    print(h_prices)
    ppl_size = int(input("Population Size: "))
    print(ppl_size)

    return cap, h_prices, gen, ppl_size

#-------------------------------------------------------------------------
def population_generation(ppl_size):
    ppl = []
    for i in range(ppl_size):
        chromo = {
            "trade_size": round(rdm.uniform(1, 10), 1),   # Trade size1% to 10%
            "stop_loss": round(rdm.uniform(1, 10), 1),    # Stop loss 1% to 10%
            "take_profit": round(rdm.uniform(1, 20), 1)   # Take profit1% to 20%
        }
        ppl.append(chromo)
    # print(ppl)
    return ppl

# ---------------------------#
def fitness(chromo, cap, h_prices):
    start_cap = cap
    t_s = chromo["trade_size"] / 100
    s_l = chromo["stop_loss"] / 100
    t_p = chromo["take_profit"] / 100

    print(t_s,s_l,t_p)

    for i in h_prices:
        t_amount = cap * t_s
        p_loss = t_amount * (i / 100)

        # print(p_loss)

        # if negative price
        if i < 0:
            if i < -s_l * 100:
                p_loss = -t_amount * s_l
        #for profit
        elif i > 0:
            if i > t_p * 100:
                p_loss = t_amount * t_p

        cap += p_loss

        # print(cap)

    P_L = cap - start_cap
    # print(P_L)

    return P_L

# Select parents randomly-------------------------------------------------#
def parents(ppl):

  rmd_ppl = rdm.sample(ppl,2)

  # print("random parents:",rmd_ppl)
  return rmd_ppl

# -----------------------------------------------------#
def singlepoint_cross(p1, p2):
    cross_point = rdm.randint(1, 2)
    c1 = {}
    c2 = {}
    keys = list(p1.keys())

    for i in range(len(keys)):
        if i < cross_point:
            c1[keys[i]] = p1[keys[i]]
            c2[keys[i]] = p2[keys[i]]
        else:
            c1[keys[i]] = p2[keys[i]]
            c2[keys[i]] = p1[keys[i]]
    # print(c1)
    # print(c2)
    return c1, c2

#----------------------------------------------------------------------#
def mutation(chromo):
    if rdm.random() < 0.05:  # 5% mutation chance
        key = rdm.choice(["stop_loss", "take_profit", "trade_size"])
        mutation_val = round(rdm.uniform(-0.5, 0.5), 1)
        # print(mutation_val)

        chromo[key] += mutation_val

        # print(chromo)
    return chromo

#----------------------------------------------------------------------------------#
def evolution(ppl, gen, cap, h_prices):
    for i in range(gen):
        f_scores = [fitness(chromo, cap, h_prices) for chromo in ppl]

        # print(f_scores)

        best_idx = f_scores.index(max(f_scores))
        best_chromo = ppl[best_idx]
        new_ppl = [best_chromo]

        # print(best_idx,best_chromo,new_ppl)

        while len(new_ppl) < len(ppl):
            p1, p2 = parents(ppl)
            c1, c2 = singlepoint_cross(p1, p2)

            # print(p1,p2)
            # print(c1,c2)

            new_ppl.append(mutation(c1))
            if len(new_ppl) < len(ppl):
                new_ppl.append(mutation(c2))

        ppl = new_ppl

    best_strategy = ppl[0]
    final_profit = fitness(best_strategy, cap, h_prices)

    # print("final profit:",final_profit)

    return best_strategy, final_profit
#------------------------------------------------------------------------------------#

cap, h_prices, gen, ppl_size = inputfile()
ppl = population_generation(ppl_size)

best_strategy, final_profit = evolution(ppl, gen, cap, h_prices)
print("--------------------------------------------------")
print(f"Best Strategy: {best_strategy}")
print(f"Final Profit: {final_profit}")





# -------------------------------------------------

#task2

def twopoint_cross(p1, p2):
    keys = list(p1.keys())
    p1_index, p2_index = sorted(rdm.sample(range(len(keys)), 2))
    c1 = p1.copy()
    c2 = p2.copy()

    for i in range(p1_index, p2_index + 1):
        temp = c1[keys[i]]

    # print(temp)

        c1[keys[i]] = c2[keys[i]]
        c2[keys[i]] = temp

        # print(c1,c2)

    return c1, c2

print("------------------------------------------------")
parents_selected = parents(ppl)
print("\nSelected Parents:")
print("Parent 1:", parents_selected[0])
print("Parent 2:", parents_selected[1])

offspring1, offspring2 = twopoint_cross(parents_selected[0], parents_selected[1])

print("\nTwo-Point Crossover Offspring:")
print("Offspring 1:", offspring1)
print("Offspring 2:", offspring2)